---
title: "Convergence of Evidence: land degrdation in Europe"
author: "M. Weynants"
date: "21/01/2021"
output: 
  bookdown::html_document2:default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(terra)
library(sf)
library(dplyr)
library(tidyr)
library(ggplot2)
wd <- getwd()

if (!dir.exists("./temp")){dir.create("./temp")}
if (!dir.exists("./fig")){dir.create("./fig")}

restart <- FALSE
# # DO NOT RUN
# # to start from scratch, execute:
# # empty dir temp
# tempfiles <- dir(path = "./temp")
# apply(tempfiles, file.remove)
# restart<- TRUE
# # END DO NOT RUN
```
## Define study area and zones
The outputs of the convergence of evidence are summarised at administrative (or other) level.
```{r zone_load}
# get official NUTS areas
if (!"eurostat" %in% installed.packages()[, 1]) {
  install.packages("eurostat")
}

if (!file.exists("./temp/zones_eu27.geojson")) {
  library(eurostat)
  reg_area3 <- get_eurostat("reg_area3") %>%
    filter(time == as.Date("2016-01-01")) %>%
    dplyr::select(geo, landuse, values) %>%
    # landuse: TSA (total surface area) = TOTAL
    #          TLA (total land area) = L0008
    pivot_wider(id_cols = geo,
                names_from = landuse,
                values_from = values) %>%
    rename(TSA = TOTAL, TLA = L0008)
  
  # load NUTS level 3 polygons in ETRS89 from EUROSTAT gisco API
  # Map Scale = Raster resolution (in meters) * 2 * 1000
  # 2e6 doesn't exist so take 1:1000000
  url_zones <-
    "https://gisco-services.ec.europa.eu/distribution/v2/nuts/geojson/NUTS_RG_01M_2021_3035_LEVL_3.geojson"
  zones <- geojsonsf::geojson_sf(url_zones)
  # cite as Â© EuroGeographics for the administrative boundaries
  # crs not properly assigned
  st_crs(zones) <- st_crs(3035)
  
  # restrict to EU27
  clip <- read_sf("../EU_dissolve/EU_dissolve.shp") %>%
    st_transform(crs = 3035)
  zones_eu27 <- zones %>%
    # EU27
    dplyr::filter(
      CNTR_CODE %in% c(
        "BE",
        "BG",
        "CZ",
        "DK",
        "DE",
        "EE",
        "IE",
        "EL",
        "ES",
        "FR",
        "HR",
        "IT",
        "CY",
        "LV",
        "LT",
        "LU",
        "HU",
        "MT",
        "NL",
        "AT",
        "PL",
        "PT",
        "RO",
        "SI",
        "SK",
        "FI",
        "SE"
      )
    ) %>%
    # remove oversea territories !!! Cyprus is missing!!!
    sf::st_intersection(clip) %>%
    # add back missing CY
    add_row(zones %>% filter(CNTR_CODE == "CY")) %>%
    # add ID
    mutate(ID = row_number()) %>%
    # add area from eurostat
    dplyr::left_join(reg_area3, by = c("NUTS_ID" = "geo"))
  # export clip
  st_write(zones_eu27, dsn = "./temp/zones_eu27.geojson")
  # reload file as SpatVect
  zones_eu27 <- vect(zones_eu27)
  rm(zones, clip)
} else {
  zones_eu27 <-
    vect(st_read("./temp/zones_eu27.geojson"))
}

```

## Load CoE output data
Assuming all issues have been processed, so that they :
- have the same equal area geographical coordinate system
- have the same extent
- are all dummy variables with values of 0 and 1
- have a consistent definition for nodata

We compute the sum of issues ignoring the no data values, i.e. no data are considered as 0. The resulting layer has integer values from 0 to (theoretically) 14, where 0 corresponds to true 0 or no data. All other values correspond to at least their number of coinciding issues.

```{r CoE_load}
path2data <- "../CoE_Europe_OUTPUT/coe_jan2022"

coe_files <- list.files( 
  path = path2data,
  pattern = "*.tif$",
  full.names = TRUE)

# define band order
band_order <-  c(
  "fires1" = "Fires",
  "treeloss_issue" = "Tree loss",
  "nitrogen" = "Nitrogen balance",
  "eutrofication_issue" = "Eutrophication",
  "acidification_issue" = "Soil acidification",
  "water_stress_issue" = "Water stress",
  "irrigationOnBWS" = "Irrigation under water stress",
  "groundwater_decline" = "Groundwater table decline",
  #"hhi" = "Household income",
  "rusle_issue" = "Water erosion",
  "wind_erosion_issue" = "Wind erosion",
  "lpd_issue" = "Land Productivity Dynamics Change",
  "pop_issue" = "Population",
  "builtup_issue" = "Built-up"
)
# coe_files <- list.files( 
#   path = path2data,
#   pattern = "*.vrt",
#   full.names = TRUE)

# # treeloss must be rounded
# treeloss <- rast(file.path(path2data,"treeloss.tif"))
# treeloss_bin <- app(treeloss, fun = function(x)(round(x)), filename = "./temp/treeloss.tif", wopt = list(datatype = "INT1U"))
# # rename original file
# file.rename(from = file.path(path2data, "treeloss.tif"), to = file.path(path2data, "treeloss_fede.tif"))
# # copy rounded file
# file.copy(from = "./temp/treeloss.tif", to = file.path(path2data, "treeloss.tif"))

# coe_list <- lapply(coe_files, function(x){rast(x)})

if(exists("coe_stack")) {rm(coe_stack)}

tryCatch(
  coe_stack <- rast(file.path(path2data, paste0(names(band_order), ".tif")))
)
if (!exists("coe_stack")) {
  print("data harmonization needed")
  ### sort out extent etc.
  # bypass by creating vrt
  file.create("./temp/buildvrtInputFiles.txt")
  write(file.path(path2data,names(band_order), ".tif"),"./temp/buildvrtInputFiles.txt")
  # set target extent to something reasonable, e.g. that of zones_eu27
  expres <- paste("gdalbuildvrt -resolution user -te", paste(as.vector(round(ext(zones_eu27)[c(1,3,2,4)])), collapse = " "), "-tr 1000 1000 -separate -r nearest -input_file_list", file.path(path2data, "buildvrtInputFiles.txt"), file.path(path2data, "coe_stack.vrt"))
  system(expres)
  coe_stack <- writeRaster(rast(file.path(path2data, "coe_stack.vrt")),
                           datatype = "INT1U",
                           filename = "./temp/coe_stack.tif")
  }

# print(coe_stack)

# set band names.
names(coe_stack) <- names(band_order)

# get resolution
reso = res(coe_stack)
# multiplication factor to get area in sqkm from cell count
mf <- reso[1] * reso[2] * 1e-6

# sum of issues
if (!file.exists("./temp/coe_soi.tif") & restart){
  coe_soi <- terra::app(coe_stack, fun = sum, na.rm = TRUE, overwrite=TRUE, filename = "./temp/coe_soi.tif") 
}
# 0 are true 0 or no data

# rasterize study area : needed to couple zones with masks 
if (restart) {
if(file.exists("./temp/rzones_eu27.tif")){file.remove("./temp/rzones_eu27.tif")}
system.time(
rzones_eu27 <- zones_eu27 %>% 
  rasterize(coe_soi, field = "ID", filename = "./temp/rzones_eu27.tif")
)
} else {
  rzones_eu27<- rast("./temp/rzones_eu27.tif")
}
# user  system elapsed 
# 0.812   0.161   1.119  
system.time(
stat_nuts <- terra::freq(rzones_eu27) %>% as.data.frame()
)
areas_nuts <- stat_nuts %>%
  left_join(as.data.frame(zones_eu27) %>% dplyr::select(ID, NUTS_ID, CNTR_CODE, URBN_TYPE, MOUNT_TYPE, COAST_TYPE), by = c("value" = "ID"))
```

## Zonal statistics
Within each administrative unit, we summarize the information:
- area affected by a co-occurrence of issues
- area affected by each issue

We look at this in different land cover classes and in function of land productivity dynamics.

### Sum of issues
```{r zstat}
# we add LC, lpd and aridity to zones
if (restart){
# Land cover reclassied as 6 classes as used for stratification
LC <- rast("../CoE_Europe_OUTPUT/LC/LandCover_3035.tif") %>%
  # resample to match zones
  project(rzones_eu27, method = "near", filename = "./temp/LC.tif")

# change in LPD between reference period (2000-2015) and reporting (2004-2019)
LPD <- rast("../CoE_Europe_OUTPUT/LPD_sumNDVI/lpd_change_option_4.tif") %>%
  # reproject
  project(rzones_eu27, method = "near", filename = "./temp/LPD.tif")
# takes much more time than LC... possibly difference in encoding?

# aridity: problem: doesn't cover all land; would introduce no data
# so i drop it from the analysis

# sum raster
comb <- function(x, y, z){x + y * 1e4 + z * 1e5}
combined_zones <- lapp(sds(rzones_eu27, LC, LPD), 
             fun = comb,
             filename = "./temp/combined_zones.tif")
soi_zones <- lapp(sds(combined_zones, coe_soi),
                 fun = function(x,y) {x + floor(y) *1e6},
                 filename = "./temp/soi_zones.tif")

# Issues
# zonal sum: sum of cells is equivalent to area in sq.km because we are in an equal area projection with 1000 m resolution AND data are 1 or 0
system.time(
stat_issues <- terra::zonal(coe_stack, combined_zones, fun = "sum", na.rm = TRUE)
)
#    user  system elapsed 
# 48.277   1.925  51.902
# i would like to have a way to know how much data
system.time(
stat_issues_data <- terra::zonal(coe_stack, combined_zones, fun = function(x, ...){sum(!is.na(x))})
)
#   user  system elapsed 
# 99.005  11.661 115.369 
tmp <- stat_issues_data %>% summarise(across(where(is.integer), sum))
# number of cells with data values depends on issue. Max is 4102215 for those defined everywhere, then 4094610 for lpd, then 4092673, for 5 issues. Min is treeloss because only on forest cells? This reflects on coe sum of issues: 0 are true 0 or no data

# Sum of issues
system.time(
stat_soi <- terra::freq(soi_zones) %>% as.data.frame()
)
# 
sum(stat_soi$count)
# 4102190, coming from the LPD.
# so we can safely use the areas from soi to analyse the individual issues.

# Prepare data for further analysis
issues_areas <- stat_issues %>%
  mutate(LPD = floor(ID * 1e-5)) %>%
  mutate(LC = floor((ID - LPD*1e5)*1e-4)) %>%
  mutate(ID = ID - LPD*1e5 - LC*1e4) %>%
  left_join(as.data.frame(zones_eu27) %>% dplyr::select(ID, NUTS_ID, CNTR_CODE, URBN_TYPE, MOUNT_TYPE, COAST_TYPE))
# I'm missing the total cell count with data at this stage...
# save data to disk
issues_areas %>% write.csv(file = "./temp/issues_areas.csv")

issues_data_areas <- stat_issues_data %>%
  mutate(LPD = floor(ID * 1e-5)) %>%
  mutate(LC = floor((ID - LPD*1e5)*1e-4)) %>%
  mutate(ID = ID - LPD*1e5 - LC*1e4) %>%
  left_join(as.data.frame(zones_eu27) %>% dplyr::select(ID, NUTS_ID, CNTR_CODE, URBN_TYPE, MOUNT_TYPE, COAST_TYPE))
save(issues_data_areas, file = "./temp/issues_data_areas")


soi_areas <- stat_soi %>%
  mutate(soi = floor(value * 1e-6)) %>%
  mutate(LPD = floor((value - soi*1e6) * 1e-5)) %>%
  mutate(LC = floor((value - soi*1e6 - LPD*1e5 )*1e-4)) %>%
  mutate(ID = value - soi*1e6 - LPD*1e5 - LC*1e4) %>%
  left_join(as.data.frame(zones_eu27) %>% dplyr::select(ID, NUTS_ID, CNTR_CODE, URBN_TYPE, MOUNT_TYPE, COAST_TYPE))
# save data to disk
soi_areas %>% write.csv(file = "./temp/soi_areas.csv")
} else{
  issues_areas <- readr::read_csv("./temp/issues_areas.csv")
  soi_areas <- readr::read_csv("./temp/soi_areas.csv")
}
```
We visualize the tabular data as bar charts. Data are available at all NUTS levels.

```{r barplottotal, fig.cap = "Frequency of number of coinciding issues for continental EU27."}
# sum of issues
soi_eu <- soi_areas %>%
  group_by(soi) %>%
  summarise(area = sum(count)) %>%
  mutate(cum_area = cumsum(area)/sum(area)*100)

p <- ggplot(soi_eu, aes(x = soi, y = area)) + geom_col()
p
# more than half of the (continental) EU has at least 3 coinciding issues.

```
Half of the (continental) EU has at least 2 coinciding issues. Maybe this graph can be skipped because it is also in the next fig \@ref(fig:soicntrplot).

```{r soicntr}
soi_cntr <- soi_areas %>%
  group_by(soi, CNTR_CODE) %>%
  summarise(area = sum(count)) %>%
  pivot_wider(names_from = soi, values_from = area, values_fill = 0) %>%
  # sort countries alphabetically
  arrange(CNTR_CODE) %>%
  # # remove is.na(CNTR_CODE) # there shouldn't be any NA
  # dplyr::filter(!is.na(CNTR_CODE)) %>%
  # add EU27 total
  bind_rows(soi_eu %>% dplyr::select(-cum_area) %>% mutate(CNTR_CODE = "EU27") %>% pivot_wider(names_from = soi, values_from = area, values_fill = 0))
knitr::kable(soi_cntr, cpation = "Areas of each EU country affected by a given number of coinciding issues.")
```
Countries do present a different distribution of the number of coinciding issues. 

```{r soicntrplot, fig.cap = "Frequency of number of coinciding issues for EU27 countries (excluding oversea territories)."}
tmp <- soi_cntr %>%
  # compute total mapped area by country
  rowwise() %>%
  mutate(cntr_area = sum(c_across(where(is.numeric)))) 
areas_cntr <- tmp %>% 
  dplyr::select(CNTR_CODE, cntr_area)%>%
  ungroup()
soi_cntr_pc <- tmp %>%
  mutate(across(where(is.numeric), ~round(.x/cntr_area*100))) %>%
  ungroup() %>%
  dplyr::select(-cntr_area) %>%
  # cntr_code to factor to fix order (alphabetical)
  mutate(CNTR_CODE = factor(CNTR_CODE, levels = pull(tmp, CNTR_CODE))) %>%
  # to long table
  pivot_longer(cols = where(is.numeric), names_to = "soi", values_to = "area")
ggplot(soi_cntr_pc,
       aes(x = as.numeric(soi), y = area)) +
  geom_col() +
  facet_wrap(~CNTR_CODE, ncol = 7)
```
```{r soicntrmean}
soi_cntr_m <- soi_cntr_pc %>%
  mutate(soixarea = as.numeric(soi) * area) %>%
  group_by(CNTR_CODE) %>%
  arrange(as.numeric(soi), by_group = TRUE) %>%
  # mutating expressions are computed within groups
  mutate(cumarea = cumsum(area)) %>%
  summarise(mean = sum(soixarea)/100, 
            mode = soi[area == max(area)][1], 
            q1 = soi[cumarea == min(cumarea[cumarea>=25])],
            median = soi[cumarea == min(cumarea[cumarea>=50])],
            q3 = soi[cumarea == min(cumarea[cumarea>=75])]) %>%
  ungroup() %>% 
  mutate(across(mode:q3, as.numeric))
```

```{r soicntrmplot, fig.cap = "Distribution statistics on number of coinciding issues for EU27 countries. Small black dot is arithmetic mean; cross (x) is mode; red dot is median; vertical line ends are first and fourth quartiles."}
lim_mean <- soi_cntr_m %>% arrange(mean) %>% dplyr::select(CNTR_CODE) %>% unlist()
names(lim_mean) <-NULL
soicntrmplot <- ggplot(soi_cntr_m %>% mutate(CNTR_CODE = factor(CNTR_CODE, levels = lim_mean)), aes(x = CNTR_CODE)) +
  geom_pointrange(mapping = aes(y = median, ymin = q1, ymax = q3), colour = "red", show.legend = TRUE) +
  geom_point(mapping = aes(y = mean),show.legend = TRUE) +
  geom_point(mapping = aes(y = mode), shape = "x", size = 4, show.legend = TRUE) +
  ylab("# coinciding issues") + 
  xlab("Countries") 
  

soicntrmplot
```

We can distinguish groups of countries. Four countries have at most one issue on half the area analysed (\@ref(fig:soicntrmplot) median, red dot): LV, EE, FI, SE. The bar charts of Finland and Sweden are similar (Fig. \@ref(fig:soicntrplot)). Their distribution's peak (mode, x in Fig.\@ref(fig:soicntrmplot)) is at no single issue or at 1 issue for Estonia. At the other extreme, six countries have more half of their mapped area subject to five or more coinciding issues: MT, DK, DE, LU, BE, NL. 
Half of the continental EU27 (without maritime territories) analysed here has at least two coinciding issues. 25% of the area has at least one issue (lower end of vertical line), while another 25% of the area has at least four coinciding issues (upper end of vertical line). The most frequent number of coinciding issues is 2 (mode, x). On average, there are 2.5 issues (mean, black dot).

```{r mapsoi}
# map of soi median at NUT3 level
soi_nuts <- soi_areas %>% 
  group_by(soi, NUTS_ID) %>%
  summarise(area = sum(count)) %>%
  pivot_wider(names_from = soi, values_from = area, values_fill = 0)
tmp <- soi_nuts %>%
  # compute total mapped area by country
  rowwise() %>%
  mutate(nuts_area = sum(c_across(where(is.numeric)))) 
areas_nuts <- tmp %>% 
  dplyr::select(NUTS_ID, nuts_area)%>%
  ungroup()
soi_nuts_pc <- tmp %>%
  mutate(across(where(is.numeric), ~round(.x/nuts_area*100))) %>%
  ungroup() %>%
  dplyr::select(-nuts_area) %>%
  # to long table
  pivot_longer(cols = where(is.numeric), names_to = "soi", values_to = "area")
# soi_nut_pc has 1152*12=13824 entries
# add expectation stats
soi_nuts_m <- soi_nuts_pc %>%
  # transform soi into numeric
  mutate(soi = as.numeric(soi)) %>%
  # basis to compute mean: soi times area
  mutate(soixarea =  soi * area) %>%
  # computations need to be made within groups
  group_by(NUTS_ID) %>%
  # sort soi values in each group to compute cumulative area, used to compute quartiles
  arrange(as.numeric(soi), by_group = TRUE) %>%
  # mutating expressions are computed within groups
  mutate(cumarea = cumsum(area)) %>%
  # summarise expressions are computed within groups
  summarise(mean = sum(soixarea)/100, 
            # if 2 soi have same area, use lowest soi.
            mode = soi[area == max(area)][1], 
            # first quartile is when at least 25% of area is covered
            q1 = soi[cumarea == min(cumarea[cumarea>=25])][1],
            median = soi[cumarea == min(cumarea[cumarea>=50])][1],
            q3 = soi[cumarea == min(cumarea[cumarea>=75])][1]) %>%
  ungroup()
# join with vect
soi_nuts_vect <- terra::merge(zones_eu27, soi_nuts_m) 
# soi_nuts_sf <- sf::st_as_sf(soi_nuts_sf) # does not work with sf version 0.9-6

plot(soi_nuts_vect, "median", lty = "blank", col = hcl.colors(8, "viridis"))
```


In the next section, we look at which are the most frequent issues.

## Issues
```{r barplotissuestotal}
# sum of issues
issues_eu <- issues_areas %>%
  # to long table
  pivot_longer(fires1:builtup_issue, names_to = "issue", values_to = "area") %>%
  group_by(issue) %>%
  summarise(area = sum(area)) %>%
  # sort by area
  arrange(area)

p <- ggplot(issues_eu, aes(x = factor(issue, levels = pull(issues_eu,issue)), y = area)) + 
  geom_col() +
  coord_flip()+ 
  xlab("") 
p
```

```{r }
issues_cntr <- issues_areas %>%
  group_by(CNTR_CODE) %>%
  summarise(across(fires1:builtup_issue, sum)) %>%
  # sort countries alphabetically
  arrange(CNTR_CODE) %>%
  # add EU27 total
  bind_rows(issues_eu %>% mutate(CNTR_CODE = "EU27") %>% pivot_wider(names_from = issue, values_from = area, values_fill = 0)) %>%
  # rearrange columns
  dplyr::select(c("CNTR_CODE", pull(issues_eu,issue)))
knitr::kable(issues_cntr, 
             cpation = "Areas [sq.km] of each EU country affected by a given issue.",
             col.names = c("Country code", band_order)
)

```

```{r issuescntrplot, fig.cap="Percentage of area in EU27 countries subject to land change issues.}
issues_cntr_pc <- issues_cntr %>%
  left_join(areas_cntr) %>%
  rowwise() %>%
  mutate(across(where(is.numeric), ~round(.x/cntr_area*100))) %>%
  ungroup() %>%
  dplyr::select(-cntr_area) %>%
  # cntr_code to factor to fix order
  mutate(CNTR_CODE = factor(CNTR_CODE, levels = pull(issues_cntr, CNTR_CODE))) %>%
  # to long table
  pivot_longer(where(is.numeric), names_to = "issue", values_to = "area") %>%
  # set issue as factor, with levels sorted by increasing area affected at EU scale
  mutate(issue = factor(issue, levels = pull(issues_eu,issue)))
  

ggplot(issues_cntr_pc,
       aes(x = issue, y = area)) +
  geom_col() +
  facet_wrap(~CNTR_CODE, ncol = 7) +
  scale_x_discrete(limits = pull(issues_eu,issue), labels = band_order ) +
  coord_flip()
```


We map the percentage of each NUTS3 in which each issue occurs.

```{r mapissues}
# map of issue percentage at NUT3 level
issues_nuts <- issues_areas %>%
  group_by(NUTS_ID) %>%
  summarise(across(fires1:builtup_issue, sum)) 

issues_nuts_pc <- issues_nuts %>%
  left_join(areas_nuts) %>%
  rowwise() %>%
  mutate(across(where(is.numeric), ~round(.x/nuts_area*100))) %>%
  ungroup() %>%
  dplyr::select(-nuts_area) #%>%
  # # to long table
  # pivot_longer(where(is.numeric), names_to = "issue", values_to = "area") %>%
  # # set issue as factor, with levels sorted by increasing area affected at EU scale
  # mutate(issue = factor(issue, levels = pull(issues_eu,issue)))


# join with vect
# soi_nuts_sf <- sf::st_as_sf(soi_nuts_sf) # does not work with sf version 0.9-6 and I can't update it
# i can load zones_eu27 as sf
zones_eu27_sf <- st_read("./temp/zones_eu27.geojson")
issues_nuts_vect <- terra::merge(zones_eu27_sf, issues_nuts_pc) 

#plot(issues_nuts_vect, "area", lty = "blank", col = hcl.colors(8, "viridis"))
# dev.new(width=12, height=10, noRStudioGD = TRUE)
# par(mfrow=c(4,7))
# for (issue in issues_eu$issue) {
#   plot(issues_nuts_vect, issue, lty = "blank", col = hcl.colors(8, "viridis"), main = band_order[grepl(issue, names(band_order))])
# }
# ggplot needs an sf
# use 2 different colour scales: 1 for issues reaching 100%, 1 for those going only up to 50
# Fires up to 35, irrigation on BWS 36, lpd 70, 
for (issue in issues_eu$issue) {
  var <- sym(issue)
  p <- ggplot(issues_nuts_vect) +
    geom_sf(aes(fill = !!var), colour = NA) +
    scale_fill_viridis_b(name = "% Area") +
    labs(title = band_order[grepl(issue, names(band_order))]) 
  ggsave(file.path("./fig", paste("map", issue, "nuts.png", sep = "_")), p,
         units = "cm", width = 15, height = 18)
  }

```

Among the land change issues analysed in this study, eutrophication is the most prominent one in the EU 27. Overall, it affects 1,928,013 km^2 (`r `issues_eu %>% filter(issue == "eutrofication_issue")`), i.e. 47 % (`r issues_cntr_pc %>% filter(CNTR_CODE == "EU27" & issue == "eutrofication_issue") %>% dplyr::select(area) `) of the area mapped. It is dominant (>75% area) in many EU27 administrative units (NUTS3). Sweden, Finland, Ireland and Cyprus are exceptions.

TO DO: correlations of % area affected by various issues

```{r issuescor}
library(GGally)
ggplot(issues_nuts_pc, aes())
```

We can also look at the data, under different perspectives.

### Highlight on arid and semi-arid areas

### Dominant land use/cover classes (end of period)

### Land productivity dynamics

<!-- ### Conventional ag -->

<!-- ### Organic ag -->

<!-- ### Regenerative ag -->

## Comparison with trends.earth outputs

compare our results with trends.earth:
TO DO 
- reproject sdg15.3 to 3035 by nearest neighbour
- zonal stat at NUTS3 level (area degrading, stable and improving)

```{r}
# 
# soi <- tabs %>% 
#   # select sum of issues
#   dplyr::filter(grepl("coe", varname)) %>%
#   # order factor
#   mutate(sum_of_issues = factor(as.numeric(as.character(Var1)), levels = seq.int(0,nlayers(coe_stack)-1))) %>%
#   # compute area as Freq x pixel area
#   mutate(area = Freq * mf) %>%
#   dplyr::select(-Var1, -Freq, -varname)
# Area <- soi$area %>% sum()
# p <- ggplot(soi, 
#     aes(y=area/Area*100, x=sum_of_issues)) + #, fill = name, colour=Var1)) +
#     geom_col( size=1, width = 0.7) +
#     #####
#     labs(
#       y = "Percentage of area",#bquote(atop('%'~of~.(lu),(.(format(Area*1e-6,digits=3))~km^{2}))), #sprintf("%% of %s (%.3f M sq.km)",lu,Area*1e-12),
#       x = "Number of coinciding issues") +
#     scale_x_discrete(limits = levels(soi$sum_of_issues))
# 
# # ggsave(filename = "sumCE.png",
# #       p+theme(text = element_text(size = 24)), 
# #       path = "./fig",
# #       width=15,
# #       height=10,
# #       units="cm")
# 
# # table output
# # - sum_of_issues
# # | nuts
# soit_nuts3 <- soi %>%
#   # sort by increasing sum_of_issues
#   arrange(sum_of_issues) %>%
#   # make table wider with number of coinciding issues as columns
#   pivot_wider(id_cols = name, names_from = sum_of_issues, names_prefix = "soi", values_from = area) %>%
#   # compute rowwise total area
#   rowwise() %>%
#   mutate(total = sum(c_across(where(is.numeric)), na.rm = TRUE)) %>%
#   ungroup() %>%
#   # add official area (from eurostat)
#   left_join(reg_area3, by = c("name" = "geo"))
#   # get area percentages
#   mutate(across(starts_with("soi"), function(x){if_else(is.na(x), 0, round(x/total*100))}, .names = "{.col}_pc") )
#   #
# #  nuts0
# soit_nuts0 <- soi  %>%
#   # sort by increasing sum_of_issues
#   arrange(sum_of_issues) %>%
#   # make table wider with number of coinciding issues as columns
#   pivot_wider(id_cols = name, names_from = sum_of_issues, names_prefix = "soi", values_from = area)%>%
#   # change names to nuts0
#   mutate(name = substr(name, start = 1, stop = 2)) %>%
#   # group and summarise by name
#   group_by(name) %>%
#   summarise(across(starts_with("soi"), ~ sum(.x, na.rm = TRUE))) %>%
#   # compute row-wise total area
#   rowwise() %>%
#   mutate(total = sum(c_across(where(is.numeric)), na.rm = TRUE)) %>%
#   ungroup() %>%
#   # get area percentages
#   mutate(across(starts_with("soi"), function(x){if_else(is.na(x), 0, round(x/total*100))}, .names = "{.col}_pc") )
#   #

```

